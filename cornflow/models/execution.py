"""
Model for the executions
"""

# Import from libraries
import hashlib

# Imports from sqlalchemy
from sqlalchemy.dialects.postgresql import JSON
from sqlalchemy.dialects.postgresql import TEXT
from sqlalchemy.sql import expression

# Imports from internal modules
from .meta_model import BaseAttributes
from ..models.instance import InstanceModel
from ..shared.utils import db


class ExecutionModel(BaseAttributes):
    """
    Model class for the Executions.
    It inherits from :class:`BaseAttributes` to have the trace fields and user field

    The :class:`ExecutionModel` has the following fields:

    - **id**: str, the primary key for the executions, a hash generated upon creation of the execution
      and the id given back to the user.
      The hash is generated from the creation date, the user and the id of the parent instance.
    - **instance_id**: str, the foreign key for the instance (:class:`InstanceModel`). It links the execution to its
      parent instance.
    - **name**: str, the name of the execution given by the user.
    - **description**: str, the description of the execution given by the user. It is optional.
    - **config**: dict (JSON), the configuration to be used in the execution (:class:`ConfigSchema`).
    - **execution_results**: dict (JSON), the results from the execution (:class:`DataSchema`).
    - **log_text**: text, the log generated by the airflow webserver during execution. This log is stored as text.
    - **log_json**: dict (JSON), the log generated by the airflow webserver during execution.
      This log is stored as a dict (JSON).
    - **finished**: bool, if the execution has finished executing in the airflow webserver.
    - **user_id**: int, the foreign key for the user (:class:`UserModel`). It links the execution to its owner.
    - **created_at**: datetime, the datetime when the execution was created (in UTC).
      This datetime is generated automatically, the user does not need to provide it.
    - **updated_at**: datetime, the datetime when the execution was last updated (in UTC).
      This datetime is generated automatically, the user does not need to provide it.
    - **deleted_at**: datetime, the datetime when the execution was deleted (in UTC). Even though it is deleted,
      actually, it is not deleted from the database, in order to have a command that cleans up deleted data
      after a certain time of its deletion.
      This datetime is generated automatically, the user does not need to provide it.

    :param dict data: the parsed json got from an endpoint that contains all the required information to
      create a new execution
    """

    # Table name in the database
    __tablename__ = 'executions'

    # Model fields
    id = db.Column(db.String(256), nullable=False, primary_key=True)
    instance_id = db.Column(db.String(256), db.ForeignKey('instances.id'), nullable=False)
    name = db.Column(db.String(256), nullable=False)
    description = db.Column(TEXT, nullable=True)
    config = db.Column(JSON, nullable=False)
    dag_run_id = db.Column(db.String(256), nullable=True)
    execution_results = db.Column(JSON, nullable=True)
    log_text = db.Column(TEXT, nullable=True)
    log_json = db.Column(JSON, nullable=True)
    finished = db.Column(db.Boolean, server_default=expression.false(), default=False, nullable=False)

    def __init__(self, data):
        super().__init__(data)
        self.user_id = data.get('user_id')
        self.instance_id = data.get('instance_id')
        # TODO: check if reference id for the instance can be modified to either be smaller or have a prefix
        #  that identifies it as an execution
        self.id = hashlib.sha1(
            (str(self.created_at) + ' ' + str(self.user_id) + ' ' + str(self.instance_id)).encode()).hexdigest()
        self.name = data.get('name')
        self.description = data.get('description', None)
        self.dag_run_id = data.get('dag_run_id', None)
        self.finished = False
        self.config = data.get('config')

    def save(self):
        """
        Saves the execution to the database
        """
        # TODO: check if we can implement any kind of rollback if needed
        db.session.add(self)
        db.session.commit()

    def update(self, data):
        """
        Updates the execution in the data base and automatically updates the updated_at field

        :param dict data:  A dictionary containing the updated data for the execution
        """
        for key, item in data.items():
            setattr(self, key, item)
        super().update(data)

    def disable(self):
        """
        Updates the deleted_at field of an execution to mark an execution as "deleted"
        """
        # TODO: if the method is the same as the parent: no need of adding it
        super().disable()

    def delete(self):
        """
        Deletes an execution permanently from the data base
        """
        db.session.delete(self)
        db.session.commit()

    @staticmethod
    def get_all_executions(user):
        """
        Query to all executions from one user.

        :param int user: User ID.
        :return: The executions of the user.
        """
        return ExecutionModel.query.filter_by(user_id=user, deleted_at=None)

    @staticmethod
    def get_one_execution_from_id(idx):
        """
        Query to get one execution with the given id

        :param str idx: Execution ID
        :return: The execution.
        """
        return ExecutionModel.query.filter_by(id=idx, deleted_at=None).first()

    @staticmethod
    def get_one_execution_from_user(user, idx):
        """
        Query to get one execution with the given id and from the user

        :param int user: User performing the query
        :param str idx: Execution ID
        :return: The execution.
        """
        return ExecutionModel.query.filter_by(user_id=user, id=idx, deleted_at=None).first()

    @staticmethod
    def get_execution_with_reference(reference_id):
        return ExecutionModel.query.filter_by(id=reference_id).first()

    @staticmethod
    def get_execution_data(idx):
        """
        Query to get the configuration of the execution and the data for the execution from its parent instance
        from a given id

        :param str idx: The reference ID of the execution.
        :return: a dict with the data from the parent instance (:class:`InstanceModel`)
          and the configuration from the execution
        :rtype: dict
        """
        execution = ExecutionModel.get_execution_with_reference(idx)
        instance_data = InstanceModel.get_one_instance_from_id(execution.instance_id).data
        config = execution.config
        return {"data": instance_data, "config": config}
        
    def __repr__(self):
        """
        Representation method

        :return: the representation of the execution as string
        :rtype: str
        """
        return '<id {}>'.format(self.id)
